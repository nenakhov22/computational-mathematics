import random
import numpy

AMOUNT_PERMUTATIONS = 0

def transpose_matrix(A):
    return [[A[j][i] for j in range(len(A))] for i in range(len(A[0]))]


def generating_Matrix(n, matrix):
    for i in range(n):
        for j in range(n):
            number_random = random.randint(0, 100)
            matrix[i][j] = number_random
    print("A = \n", end='')
    print(numpy.matrix(matrix), '\n')


def LU_decomosition(n, A, P):
    global AMOUNT_PERMUTATIONS
    #поиск опорного элемента
    rank = n
    for i in range(len(A)):
        pivot_value = 0
        pivot = -1
        for row in range(i, len(A)):
            if abs(A[row][i]) > pivot_value:
                pivot_value = A[row][i]
                pivot = row
        #меняем местами i - ю строку и строку с опорным элементом
        if(pivot_value<1e-14):
            rank=i
            break
        if pivot_value != 0:
            AMOUNT_PERMUTATIONS+=1
            P[i], P[pivot] = P[pivot], P[i]
            A[i], A[pivot] = A[pivot], A[i]
            for j in range(i + 1, len(A)):
                A[j][i] /= A[i][i]
                for k in range(i + 1, len(A)):
                    A[j][k] -= A[j][i] * A[i][k]
    print("Матрица после LUP разложения", '\n')
    print(numpy.matrix(A))
    return rank

# решаем уравнение Ax = b
#сюда фактические передаем не b а Pb
def solving_equation(A, b,U,rank):
    y = [0 for i in range(len(A))]
    #(Ly=Pb,L-верхняя треугольная)
    for i in range(len(y)):
        y[i] = b[i] - sum([A[i][k] * y[k] for k in range(0, i)])
    for i in range(U.shape[0]):
        if (abs(U[i,i])<1e-12):
            if(abs(y[i])>1e-12):
                raise BaseException("решение не существует")
            else:
                continue
    x = [0 for i in range(len(A))]
    #(Ux=y,U-нижняя треугольная)
    for i in range(rank - 1, -1, -1):
        x[i] = (y[i] - sum([A[i][k] * x[k] for k in range(i + 1, len(y))])) / A[i][i]
    return x





# вычисляем определитель
def determinant(A):
    detA = 1
    for i in range(len(A)):
        detA *= A[i][i]
    #detA = detA if AMOUNT_PERMUTATIONS % 2 == 0 else -detA
    return detA

def check_solution(A, x, b):
    print("Ax - b =", numpy.subtract(numpy.matmul(A, x), b))

def main():
    matrix_size = int(input())
    A = [[0] * matrix_size for i in range(matrix_size)]
    generating_Matrix(matrix_size, A)
    A_copy = numpy.copy(A)
    P = [i for i in range(matrix_size)]

    rank=LU_decomosition(matrix_size, A, P)
    U=numpy.copy(A)
    L=numpy.eye(matrix_size)
    for i in range(1,matrix_size):
        for j in range(0,i):
            L[i,j]=A[i][j]
            U[i,j]=0
    print('L=\n',L,'\nU=\n',U,';','\nLU=\n',numpy.matmul(L,U),'\nPA=\n',numpy.matmul([[1 if P[i]==j else 0 for j in range(matrix_size)] for i in range(matrix_size)],A_copy))
    b = [random.randint(0, 100) for i in range(len(P))]
    b_copy = b[:]
    for i in range(len(P)):
        b[i] = b_copy[P[i]]
    try:
        x = solving_equation(A, b,U,rank)
        for i in range(len(b)):
            print("b_{} = ".format(i + 1), b[i])
        print("Решение матричного уравнения:  \n ")
        for i in range(len(x)):
            print("x_{} = ".format(i + 1), x[i])
        print(check_solution(A_copy, x, b_copy))
    except BaseException as e:
        print(e)
    #print(numpy.matrix(b_copy))
    print("\n ОПРЕДЕЛИТЕЛЬ матрицы A:  \n ", determinant(A))
    print(" \n ****** Матрица b******: ")
    



main()
